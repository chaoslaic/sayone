# 简单说一下JVM

## JVM体系结构

JVM（Java Virtual Machine，Java虚拟机）是一种抽象的计算机，基于堆栈架构，有自己的指令集和内存管理。一次编译，到处运行。JVM体系结构由以下三部分组成。

- 类加载器（Class Loader）：处理类的动态加载，还有链接，并且在第一次引用类时进行初始化。
- 运行时数据区：约定了在运行时程序代码的数据的存储位置。
- 执行引擎（Execution Engine）：运行时数据区存储着要执行的字节码，执行引擎将会读取并逐个执行。

### JRE、JDK、JVM的区别

使用JDK（调用JAVA API）开发JAVA程序后，通过JDK中的编译程序（javac）将Java程序编译为Java字节码，在JRE上运行这些字节码，JVM会解析并映射到真实操作系统的CPU指令集和OS的系统调用。

- JRE（Java Runtime Environment，Java运行环境）是Java平台，所有的程序都要在JRE下才能够运行。包括JVM和Java核心类库和支持文件。
- JDK（Java Development Kit，Java开发工具包）是用来编译、调试Java程序的开发工具包。包括Java工具（javac/java/jdb等）和Java基础的类库（java API）。
- JVM（Java Virtual Machine，Java虚拟机）是JRE的一部分。JVM主要工作是解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。Java语言是跨平台运行的，不同的操作系统会有不同的JVM映射规则，使之与操作系统无关，完成跨平台性。

## 类加载器

### 类文件结构

- 魔法值：cafebabe。
- 版本号：最小版本号、最大版本号。
- 常量池表：常量池数量、常量池集合（存放字面量、符号引用）。
- 类对象：访问标志、类名、父类。
- 接口表：接口数量、接口集合。
- 字段表：字段数量、字段集合（接口或类中声明的变量）。
- 方法表：方法数量、方法集合。
- 属性表：属性数量、属性集合（Class文件、字段表、方法表中变量的属性值）。

### javac的七个阶段

- parse：读取.java源文件，做词法分析和语法分析。
- enter：生成符号表。
- process：处理注解。
- attr：检查语义合法性、常量折叠。
- flow：数据流分析。
- desugar：去除语法糖。
- generate：生成字节码。

### 类加载的生命周期

- 加载：加载类的二进制字节流，在内存区中生成类的Class对象。
- 链接
  - 验证：文件格式、元数据、字节码、符号引用。
  - 准备：类变量的初始值。
  - 解析：直接引用、常量池。
- 初始化：new、按次序先初始化父类的静态块、静态变量。
- 使用
- 卸载

### 三种类加载器

- 启动类加载器：/lib/rt.jar。
- 扩展类加载器：/lib/ext/。
- 应用程序类加载器：类路径中指定的类。

### 双亲委派

- 判断当前ClassLoader是否已经加载过，加载过直接返回Class对象。
- 没加载让父ClassLoader加载，加载成功返回Class对象。
- 父ClassLoader没有加载成功，自己尝试加载。

findClass：一开始就有ClassLoader#loadClass，1.2之后引入双亲委派，逻辑在loadClass方法。

### 模块化

- 类路径、模块路径。
- 类路径下的JAR文件及资源文件自动打包在匿名模块。
- 模块路径下的具名模块只能访问所依赖中定义列明的模块和包。
- 平台类加载器替换掉扩展类加载器。

## 运行时数据区

- 方法区：运行时常量池、类信息。
- Java堆：类对象。
- 程序计数器：执行字节码的行号指示器。
- 本地方法栈：本地方法的数据。
- Java虚拟机栈：Java方法的数据。
  - 局部变量表：存放方法参数和方法内部定义的局部变量。
  - 操作数栈：后入先出，字节码指令进行出栈入栈。
  - 栈帧信息
    - 动态连接：每一次运行期间将栈帧所属方法的符号引用转化为直接引用。
    - 方法返回地址：恢复上层方法的局部变量表和操作数栈。
    - 附加信息：调试、性能收集。

### 字节码

- 加载和存储指令：load类、store类、常量加载。
- 操作数栈指令：pop、dup、swap。
- 运算和类型转换指令：加减乘除、cast。
- 控制转移指令：有条件转移、复合条件转移、无条件转移。
- 方法调用指令：五种。
  - invokestatic：调用竟态方法。
  - invokespecial（早期版本为invokenonvirtual）：调用私有实例方法、构造器方法、父类实例方法。
  - invokevirtual：调用非私有实例方法。
  - invokeinterface：调用接口方法。
  - invokedynamic：调用动态方法。

### JVM内存结构

- JVM内存结构：和Java虚拟机的运行时区域有关。
- Java内存模型：和Java的并发编程有关。
- Java对象模型：和Java对象在虚拟机中的表现形式有关。

### 创建对象过程

new、dup、invokespecial

父类的类构造器 -> 子类的类构造器 -> 父类的成员变量和实例代码块 -> 父类的构造方法 -> 子类的成员变量和实例代码块 -> 子类的构造方法。

- new指令触发：new、newInstance、clone、序列化。
类初始化（new）：当Java虚拟机遇到一条字节码new指令时，检查这个指令的参数能否在常量池中定位到一个类的符号引用，这个符号引用代表的类是否已被加载、解析和初始化。
实例初始化（invokespecial）：实例字段、实例代码块、实例默认构造方法。

- 分配内存（Java堆）：分配并发问题通过CAS解决，或通过TLAB预先分配内存。
  - 指针碰撞：使用Serial、ParNew标记整理的收集器，指针指向空闲空间。
  - 空闲列表：使用CMS标记清除的收集器，需要维护一个内存空闲列表。

### 对象结构

- 对象头
  - 类型指针：指向类型元数据（类信息）的指针。
  - 对象运行时数据：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。数据长度根据机器位数决定，可通过压缩指针将64位减为32位。
- 实例数据：父类定义的变量会出现在子类之前。
- 对齐补充：8字节的整数倍。

在64和32位系统下，占位均如以下，不同的是64位CPU一次可提取64位数据，32位的只能提取32位数据。

- boolean：8分之1字节。
- byte：1个字节、2的8次方-1、负的2的8次方。
- char：1个字节、0、2的17次方-1。
- short：2个字节、2的16次方-1、负的2的16次方。
- int：4字节、2的32次方-1、负的2的32次方。
- float：4字节2的128次方-1、2的-149次方。
- long：8字节、2的64次方-1、负的2的64次方。
- double：8字节、2的1024次方-1、2的-1074次方。

- 一个空对象占8字节。
- 一个boolean字段的类实例占16字节：头信息占8字节，boolean占1字节，为了对齐额外占用7个字节。
- 八个boolean字段的类实例占16字节：头信息占8字节，boolean占8字节；8的倍数不需要对齐补充。
- 2个long字段、3个int字段、1个boolean字段的类实例占40字节：头信息占8字节、每个long占8字节、每个int占12字节、每个boolean占1字节，对齐补充后占40字节。

### 性能监控、故障处理

- jps（JVM Process Status Tool）：虚拟机进程状况工具。
- jstat（JVM Statistics Monitoring Tool）：虚拟机统计信息监视工具。
- jinfo（Configuration Info for Java）：Java配置信息工具。
- jmap（Memory Map for Java）：Java内存映像工具。
- jhat（Java Heap Analysis Tool）：虚拟机堆转储快照分析工具。
- jstack（Stack Trace for Java）：Java堆栈跟踪工具。

### 参数设置

4核cpu，8g内存，256g

 -Xms6000m -Xmx6000m -Xmn3000m -Xss3m -Xloggc:logs/application-gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps

- Xms：是指设定程序启动时占用内存大小。一般来讲，大点，程序会启动的快一点，但是也可能会导致机器暂时间变慢。
- Xmx：是指设定程序运行期间最大可占用的内存大小。如果程序运行需要占用更多的内存，超出了这个设置值，就会抛出OutOfMemory异常。
- Xmn：年轻代大小。
- Xss：是指设定每个线程的堆栈大小。这个就要依据你的程序，看一个线程大约需要占用多少内存，可能会有多少线程同时运行等。

## 执行引擎

- Interpreter：解释器，它对字节码的解释很快，但执行慢，有个缺点是，当方法被多次调用时，每次都需要重新解释。
- JIT Compiler：JIT编译器，解决了解释器的缺点，仍使用解释器来转换字节代码，但发现有代码重复执行时，会使用JIT编译器，将整个字节码编译成本地代码，将本地代码用于重复调用。
- Garbage Collector：垃圾收集器，收集和删除未引用的对象。

### 垃圾回收

#### 判断对象是否存活

- 引用计数法
- 可达性分析法
  - Java虚拟机栈中引用的对象
  - 方法区中类静态属性引用的对象
  - 方法区中常量引用的对象
  - 本地方法栈中JNI引用的对象
  - 虚拟机内部的引用
  - 被同步锁持有的对象

#### 对象引用强度

- 强引用：不回收。
- 软引用：内存溢出前回收。
- 弱引用：gc时回收。
- 虚引用：被gc回收时可设置系统通知。

#### 垃圾收集算法

- 标记清除
- 标记复制
- 标记整理

新生代：标记复制。
老年代：标记整理。

#### 垃圾收集器分类

- 串行回收
- 并行回收
- 并发标记回收
- 垃圾优先回收

#### cms、g1垃圾收集器

- 初始标记
- 并发标记
- 最终标记
- 筛选回收
