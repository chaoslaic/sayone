# 简单说一下IO

## 基本术语

### 内存

内存在计算机运行时为操作系统和各种程序提供临时存储。

- 虚拟内存：将硬盘的一块区域划分出来作为内存。
- 物理内存：通过物理内存条而获得的内存。

- 内核空间：内核程序，可完全访问所有空间和计算机硬件。
- 用户空间：应用程序，存储其堆栈等。
- 内存空间：内核空间和用户空间。

- 逻辑地址：程序编译后，生成的目标模块进行编址时都是从0号单元开始编址。
- 物理地址：加载到内存地址寄存器中的地址，内存单元的真正地址。
- 内存管理单元：管理着逻辑地址和物理地址的转换。

- 页：用户空间划分为大小相等的部分称为页，对应逻辑地址。
- 页框：内存空间划分为同样大小的区域称为页框，对应物理地址。
- 页表：页表存储着页和页框的映射表。页表中还包含包含有效位（是在内存还是磁盘）、访问位（是否被访问过）、修改位（内存中是否被修改过）、保护位（只读还是可读写）。

- 页式存储：分配时以页为单位，按用户进程需要的页数分配，逻辑上相邻的页物理上不一定相邻。
- 段式存储：用户进程按照自身逻辑关系划分为若干个段（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻。
- 段页式存储：用户进程先按段划分，段内再按页划分。

每个进程所能使用的逻辑地址大小和CPU位数有关。在32位的系统上，逻辑地址空间大小是2^32=4G，在64位系统上，逻辑地址空间大小是2^64=2^34G。

### 文件句柄（文件描述符）

- shell级限制：默认1024，ulimit -n，当前shell的当前用户所有进程能打开的最大文件数量。
- 用户级限制：默认65535，/etc/security/limits.conf，用户能打开的最大文件数量，不管它开启多少个shell。
- 系统级限制：默认794168，/proc/sys/fs/file-max，系统给出的建议值。

### IO读写原理

内核态与用户态是指CPU的运行状态（特权级别），每个进程的每种CPU状态都有其运行上下文，运行上下文就包括了当前状态所使用的空间，CPU访问的逻辑地址通过地址映射表映射到相应的物理地址。进程的内核空间公用而用户空间独立，进程切换时内核空间不变而用户空间切换。处于内核态时可访问所有地址空间，而处于用户态时只能访问用户空间。

数据获取由用户态的应用进程发起，进程切换到内核态等待数据（网络IO、磁盘IO等）到内核空间，之后将数据复制到用户空间，最后切换回用户态操作数据。

- 内核空间操作：CPU将数据从文件（网络IO、磁盘IO）复制到内核空间。
- 用户空间操作：CPU将数据从内核空间复制到用户空间。

IO读写可分为三种方式。

- 轮询：是基于死循环对IO端口进行不断检测。
- IO中断：是指当数据到达时，磁盘主动向CPU发起中断请求，由CPU自身负责数据的传输过程。
- DMA传输：是在IO中断的基础上引入了DMA磁盘控制器，由DMA磁盘控制器负责数据的传输，降低了IO中断操作对CPU资源的大量消耗。

#### IO中断原理

在DMA技术出现之前，应用程序与磁盘之间的IO操作都是通过CPU的中断完成的。每次用户进程读取磁盘数据时，都需要CPU中断，然后发起IO请求等待数据读取和拷贝完成，每次的IO中断都导致CPU的上下文切换。

- 用户进程向CPU发起read系统调用读取数据，由用户态切换为内核态，然后一直阻塞等待数据的返回。
- CPU在接收到指令以后对磁盘发起IO请求，将磁盘数据先放入磁盘控制器缓冲区。
- 数据准备完成以后，磁盘向CPU发起IO中断。
- CPU收到IO中断以后将磁盘缓冲区中的数据拷贝到内核缓冲区，然后再从内核缓冲区拷贝到用户缓冲区。
- 用户进程由内核态切换回用户态，解除阻塞状态，然后等待CPU的下一个执行时间钟。

#### DMA传输原理

DMA的全称叫直接存储器访问（Direct Memory Access），是一种允许外围设备（硬件子系统）直接访问系统主内存的机制。也就是说，基于DMA访问方式，系统主内存于硬盘或网卡之间的数据传输可以绕开CPU的全程调度。目前大多数的硬件设备，包括磁盘控制器、网卡、显卡以及声卡等都支持DMA技术。

- 用户进程向CPU发起read系统调用读取数据，由用户态切换为内核态，然后一直阻塞等待数据的返回。
- CPU在接收到指令以后对DMA磁盘控制器发起调度指令。
- DMA磁盘控制器对磁盘发起IO请求，将磁盘数据先放入磁盘控制器缓冲区，CPU全程不参与此过程。
- 数据读取完成后，DMA磁盘控制器会接受到磁盘的通知，将数据从磁盘控制器缓冲区拷贝到内核缓冲区。
- DMA磁盘控制器向CPU发出数据读完的信号，由CPU负责将数据从内核缓冲区拷贝到用户缓冲区。
- 用户进程由内核态切换回用户态，解除阻塞状态，然后等待CPU的下一个执行时间钟。

## 五种IO模型

同步和异步是指CPU时间片的利用，看请求方对消息结果的获取是主动发起的还是被动通知的。阻塞和非阻塞是针对IO的操作。

- 同步：请求方主动获取消息结果。
- 异步：服务方通知请求方消息结果，一般通过状态改变、消息通知、回调函数。
- 阻塞：等待函数返回结果之前，当前线程挂起状态。
- 非阻塞：等待函数返回结果之前，当前线程运行状态。

根据组合可分为五种IO模型。

- 同步阻塞IO：应用进程发起数据获取，应用进程阻塞等待内核空间、用户空间的操作。
- 同步非阻塞IO：应用进程发起数据获取，应用进程轮询内核空间是否已操作，操作后应用进程阻塞等待用户空间的操作。
- IO多路复用：应用进程发起数据获取，应用进程阻塞获取已就绪的连接（就绪列表中有内核空间已操作的连接），获取后应用进程阻塞等待用户空间的操作。
- 信号驱动IO：应用进程发起数据获取，内核空间已操作后通知应用进程，应用进程阻塞等待用户空间的操作。
- 异步IO：应用进程发起数据获取，内核空间、用户空间已操作后通知应用进程。

## IO多路复用

IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。

- select：1024线程限制且非线程安全。
- poll：无线程限制，但非线程安全。
- epoll：无线程限制，线程安全。

- channel表示网络连接。
- selector监视多个文件描述符。
- buffer与channel进行数据读写。

## 零拷贝

零拷贝（Zero-copy）技术指在计算机执行操作时，CPU不需要先将数据从一个内存区域复制到另一个内存区域，从而可以减少上下文切换以及CPU的拷贝时间。它的作用是在数据报从网络设备到用户程序空间传递的过程中，减少数据拷贝次数，减少系统调用，实现CPU的零参与，彻底消除CPU在这方面的负载。实现零拷贝用到的最主要技术是DMA数据传输技术和内存区域映射技术。

- 减少数据在内核缓冲区和用户进程缓冲区之间反复的IO拷贝操作。
- 减少用户进程地址空间和内核地址空间之间因为上下文切换而带来的CPU开销。

### 传统读操作

当应用程序执行read系统调用读取一块数据的时候，如果这块数据已经存在于用户进程的页内存中，就直接从内存中读取数据；如果数据不存在，则先将数据从磁盘加载数据到内核空间的读缓存（read buffer）中，再从读缓存拷贝到用户进程的页内存中。

基于传统的IO读取方式，read系统调用会触发2次上下文切换，1次DMA拷贝和1次CPU拷贝，发起数据读取的流程如下：

- 用户进程通过read()函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。
- CPU利用DMA控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）。
- CPU将读缓冲区（read buffer）中的数据拷贝到用户空间（user space）的用户缓冲区（user buffer）。
- 上下文从内核态（kernel space）切换回用户态（user space），read 调用执行返回。

### 传统写操作

当应用程序准备好数据，执行write系统调用发送网络数据时，先将数据从用户空间的页缓存拷贝到内核空间的网络缓冲区（socket buffer）中，然后再将写缓存中的数据拷贝到网卡设备完成数据发送。

基于传统的IO写入方式，write()系统调用会触发2次上下文切换，1次CPU拷贝和1次DMA拷贝，用户程序发送网络数据的流程如下：

- 用户进程通过write()函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。
- CPU将用户缓冲区（user buffer）中的数据拷贝到内核空间（kernel space）的网络缓冲区（socket buffer）。
- CPU利用DMA控制器将数据从网络缓冲区（socket buffer）拷贝到网卡进行数据传输。
- 上下文从内核态（kernel space）切换回用户态（user space），write 系统调用执行返回。

### Linux零拷贝方式

在Linux中零拷贝技术主要有3个实现思路：用户态直接IO、减少数据拷贝次数以及写时复制技术。

- 用户态直接IO：应用程序可以直接访问硬件存储，操作系统内核只是辅助数据传输。这种方式依旧存在用户空间和内核空间的上下文切换，硬件上的数据直接拷贝至了用户空间，不经过内核空间。因此，直接IO不存在内核空间缓冲区和用户空间缓冲区之间的数据拷贝。
- 减少数据拷贝次数：在数据传输过程中，避免数据在用户空间缓冲区和系统内核空间缓冲区之间的CPU拷贝，以及数据在系统内核空间内的CPU拷贝，这也是当前主流零拷贝技术的实现思路。
- 写时复制技术：写时复制指的是当多个进程共享同一块数据时，如果其中一个进程需要对这份数据进行修改，那么将其拷贝到自己的进程地址空间中，如果只是数据读取操作则不需要进行拷贝操作。

#### 用户态直接IO

用户态直接IO只能适用于不需要内核缓冲区处理的应用程序，这些应用程序通常在进程地址空间有自己的数据缓存机制，称为自缓存应用程序，如数据库管理系统就是一个代表。其次，这种零拷贝机制会直接操作磁盘IO，由于CPU和磁盘IO之间的执行时间差距，会造成大量资源的浪费，解决方案是配合异步IO使用。

#### mmap + write

一种零拷贝方式是使用mmap + write代替原来的read + write方式，减少了1次CPU拷贝操作。mmap是Linux提供的一种内存映射文件方法，即将一个进程的地址空间中的一段虚拟地址映射到磁盘文件地址。

基于mmap + write系统调用的零拷贝方式，整个拷贝过程会发生4次上下文切换，1次CPU拷贝和2次DMA拷贝，用户程序读写数据的流程如下：

- 用户进程通过mmap()函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。
- 将用户进程的内核空间的读缓冲区（read buffer）与用户空间的缓存区（user buffer）进行内存地址映射。
- CPU利用DMA控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）。
- 上下文从内核态（kernel space）切换回用户态（user space），mmap系统调用执行返回。
- 用户进程通过write()函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。
- CPU将读缓冲区（read buffer）中的数据拷贝到的网络缓冲区（socket buffer）。
- CPU利用DMA控制器将数据从网络缓冲区（socket buffer）拷贝到网卡进行数据传输。
- 上下文从内核态（kernel space）切换回用户态（user space），write系统调用执行返回。

mmap主要的用处是提高IO性能，特别是针对大文件。对于小文件，内存映射文件反而会导致碎片空间的浪费，因为内存映射总是要对齐页边界，最小单位是4KB，一个5KB的文件将会映射占用8KB内存，也就会浪费3KB内存。

#### sendfile

sendfile系统调用在Linux内核版本2.1中被引入，适用于将数据从文件拷贝到socket套接字，需要硬件的支持，不能对数据进行修改。

基于sendfile系统调用的零拷贝方式，整个拷贝过程会发生2次上下文切换，1次CPU拷贝和2次DMA拷贝，用户程序读写数据的流程如下：

- 用户进程通过sendfile()函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。
- CPU利用DMA控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）。
- CPU将读缓冲区（read buffer）中的数据拷贝到的网络缓冲区（socket buffer）。
- CPU利用DMA控制器将数据从网络缓冲区（socket buffer）拷贝到网卡进行数据传输。
- 上下文从内核态（kernel space）切换回用户态（user space），sendfile系统调用执行返回。

#### sendfile + DMA gather copy

Linux2.4版本的内核对sendfile系统调用进行修改，为DMA拷贝引入了gather操作。它将内核空间（kernel space）的读缓冲区（read buffer）中对应的数据描述信息（内存地址、地址偏移量）记录到相应的网络缓冲区（socket buffer）中，由DMA根据内存地址、地址偏移量将数据批量地从读缓冲区（read buffer）拷贝到网卡设备中，这样就省去了内核空间中仅剩的1次CPU拷贝操作。

基于sendfile + DMA gather copy系统调用的零拷贝方式，整个拷贝过程会发生2次上下文切换、0次CPU拷贝以及2次DMA拷贝，用户程序读写数据的流程如下：

- 用户进程通过sendfile()函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。
- CPU利用DMA控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）。
- CPU把读缓冲区（read buffer）的文件描述符（file descriptor）和数据长度拷贝到网络缓冲区（socket buffer）。
- 基于已拷贝的文件描述符（file descriptor）和数据长度，CPU利用DMA控制器的gather/scatter操作直接批量地将数据从内核的读缓冲区（read buffer）拷贝到网卡进行数据传输。
- 上下文从内核态（kernel space）切换回用户态（user space），sendfile系统调用执行返回。

#### splice

Linux在2.6.17版本引入splice系统调用，适用两个文件描述符之间的数据零拷贝，不需要硬件支持，不能对数据进行修改。

基于splice系统调用的零拷贝方式，整个拷贝过程会发生2次上下文切换，0次CPU拷贝以及2次DMA拷贝，用户程序读写数据的流程如下：

- 用户进程通过splice()函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。
- CPU利用DMA控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）。
- CPU在内核空间的读缓冲区（read buffer）和网络缓冲区（socket buffer）之间建立管道（pipeline）。
- CPU利用DMA控制器将数据从网络缓冲区（socket buffer）拷贝到网卡进行数据传输。
- 上下文从内核态（kernel space）切换回用户态（user space），splice系统调用执行返回。

#### 写时复制

在某些情况下，内核缓冲区可能被多个进程所共享，如果某个进程想要这个共享区进行write操作，由于write不提供任何的锁操作，那么就会对共享区中的数据造成破坏，写时复制的引入就是Linux用来保护数据的。

#### 缓冲区共享

缓冲区共享方式完全改写了传统的IO操作，因为传统IO接口都是基于数据拷贝进行的，要避免拷贝就得去掉原先的那套接口并重新改写，所以这种方法是比较全面的零拷贝技术，目前比较成熟的一个方案是在Solaris上实现的fbuf（Fast Buffer，快速缓冲区）。

fbuf的思想是每个进程都维护着一个缓冲区池，这个缓冲区池能被同时映射到用户空间（user space）和内核态（kernel space），内核和用户共享这个缓冲区池，这样就避免了一系列的拷贝操作。

缓冲区共享的难度在于管理共享缓冲区池需要应用程序、网络软件以及设备驱动程序之间的紧密合作，而且如何改写API目前还处于试验阶段并不成熟。

### Java零拷贝方式

在Java NIO中的通道（Channel）就相当于操作系统的内核空间（kernel space）的缓冲区，而缓冲区（Buffer）对应的相当于操作系统的用户空间（user space）中的用户缓冲区（user buffer）。

- 通道（Channel）是全双工的（双向传输），它既可能是读缓冲区（read buffer），也可能是网络缓冲区（socket buffer）。
- 缓冲区（Buffer）分为堆内存（HeapBuffer）和堆外内存（DirectBuffer），这是通过malloc()分配出来的用户态内存。

堆外内存（DirectBuffer）在使用后需要应用程序手动回收，而堆内存（HeapBuffer）的数据在GC时可能会被自动回收。因此，在使用HeapBuffer读写数据时，为了避免缓冲区数据因为GC而丢失，NIO会先把HeapBuffer内部的数据拷贝到一个临时的DirectBuffer中的本地内存（native memory），这个拷贝涉及到sun.misc.Unsafe.copyMemory()的调用，背后的实现原理与memcpy()类似。最后，将临时生成的DirectBuffer内部的数据的内存地址传给IO调用函数，这样就避免了再去访问Java对象处理IO读写。

- MappedByteBuffer：是NIO基于内存映射（mmap）这种零拷贝方式的提供的一种实现，它继承自ByteBuffer。
- DirectByteBuffer：是MappedByteBuffer的具体实现类，还提供了内存映像文件的随机读取get()和写入write()的操作。
- FileChannel：是一个用于文件读写、映射和操作的通道，基于sendfile实现数据传输，依赖操作系统实现。

### Netty零拷贝方式

Netty中的零拷贝和上面提到的操作系统层面上的零拷贝不太一样，我们所说的Netty零拷贝完全是基于用户态（Java层面），它的更多的是偏向于数据操作优化这样的概念，具体表现在以下几个方面：

- Netty通过DefaultFileRegion类对java.nio.channels.FileChannel的tranferTo()方法进行包装，在文件传输时可以将文件缓冲区的数据直接发送到目的通道（Channel）。
- ByteBuf可以通过wrap操作把字节数组、ByteBuf、ByteBuffer包装成一个ByteBuf对象，进而避免了拷贝操作。
- ByteBuf支持slice操作，因此可以将ByteBuf分解为多个共享同一个存储区域的ByteBuf，避免了内存的拷贝。
- Netty提供了CompositeByteBuf类，它可以将多个ByteBuf合并为一个逻辑上的ByteBuf，避免了各个ByteBuf之间的拷贝。

其中第1条属于操作系统层面的零拷贝操作，后面3条只能算用户层面的数据操作优化。

### RocketMQ、Kafka零拷贝方式

- RocketMQ选择了mmap + write这种零拷贝方式，适用于业务级消息这种小块文件的数据持久化和传输。
- Kafka采用的是sendfile这种零拷贝方式，适用于系统日志消息这种高吞吐量的大块文件的数据持久化和传输。但是值得注意的一点是，Kafka的索引文件使用的是mmap + write方式，数据文件使用的是sendfile方式。

## 中间件并发数

- MySQL：默认连接数是100，最大连接数是16384。
- Tomcat：默认150，因为需要访问数据库、调用网络资源，且一个线程耗用1MB内存。支持BIO、NIO、APR三种接收请求的方式。
- Nginx：2w，反向代理Web服务器。
- Redis：10w，单线程io模式，纯内存操作。

### Redis

Redis客户端对服务端的每次调用都经历了发送命令，执行命令，返回结果三个过程。其中执行命令阶段，由于Redis是单线程来处理命令的，所有每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行。并且多个客户端发送的命令的执行顺序是不确定的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题，这就是Redis的单线程基本模型。

Redis服务器是一个事件驱动程序。下面先来简单介绍什么是事件驱动。

所谓事件驱动，就是当你输入一条命令并且按下回车，然后消息被组装成Redis协议的格式发送给Redis服务器，这就会产生一个事件，Redis服务器会接收该命令，处理该命令和发送回复，而当你没有与服务器进行交互时，那么服务器就会处于阻塞等待状态，会让出CPU从而进入睡眠状态，当事件触发时，就会被操作系统唤醒。事件驱动使CPU更高效的利用。

事件驱动是一种概括和抽象，也可以称为I/O多路复用（I/O multiplexing），它的实现方式各个系统都不同，一会会说到Redis的方式。

在redis服务器中，处理了两类事件：

- 文件事件：Redis服务器通过套接字于客户端（或其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。
- 时间事件：Redis服务器的一些操作需要在给定的事件点执行，而时间事件就是服务器对这类定时操作的抽象。
