# 简单说一下MySQL

## MySQL体系结构

- 连接池组件：Connection Limits等。
- 管理服务和工具组件：Backup、Recovery等。
- SQL接口组件：DML、DDL等。
- 查询分析器组件
- 优化器组件
- 缓冲组件
- 插件式存储引擎：InnoDB、MyISAM等。
- 物理文件：NTFS、ufs等。

### 数据库和实例

- 数据库：是由一个个文件组成的。
- 数据库实例：操作文件是操作不了数据库的，而要通过数据库实例来操作。

### MySQL存储引擎

show engines;

- InnoDB
  - 支持事务、行级锁定和外键，OLTP应用的首选。
  - frm、ibd，主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值。
  - truncate清空数据但不释放表空间。
- MyISAM
  - 不支持事务，表锁设计，OLAP应用的首选。
  - frm、myd、myi，主键索引和辅助索引的叶子节点都是数据文件的地址指针。
  - truncate清空数据并释放表空间。

### MySQL文件

- 参数文件：告诉MySQL实例启动时在哪里可以找到数据库文件，并且指定某些初始化参数。
- 日志文件：用来记录MySQL实例对某种条件做出响应时写入的文件。
  - 错误日志文件：对MySQL的启动、运行、关闭过程进行了记录。
  - 慢查询日志文件：将运行时间超过阈值的SQL语句进行了记录。
  - 查询日志文件：对MySQL数据库请求的信息进行了记录，无论是否得到了正确的执行。
  - 二进制日志文件：对MySQL数据库执行更改的信息进行了记录，不包括查询类操作。
- socket文件：当用unix域套接字方式进行连接时需要的文件。
- pid文件：MySQL实例的进程id文件。
- MySQL表结构文件：用来存放MySQL表结构定义文件。
- InnoDB存储引擎文件
  - 表空间文件：管理InnoDB存储引擎的存储，分为共享表空间和独立表空间。
  - 重做日志文件：记录了事务日志。

## InnoDB存储引擎

### InnoDB体系架构

- 后台线程：负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据。此外将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态。
  - Master Thread：将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括合并插入缓冲、脏页的刷新、undo页的回收。
  - IO Thread：负责IO请求的回调处理。write、read、insert buffer、log IO。
  - Purge Thread：undo页的回收。
  - Page Cleaner Thread：脏页的刷新。
- 内存
  - 缓冲池：一块内存区域，通过内存的速度来弥补磁盘速度较慢的问题。缓存的数据页类型有：索引页、数据页、undo页、插入缓冲、自适应哈希索引、InnoDB存储的锁信息、数据字典信息等。
  - 内存区域管理：LRU List、Free List和Flush List。
  - 重做日志缓冲：首先将重做日志信息先放入到这个缓冲区，然后按一定频率将其刷新到重做日志文件。
  - 额外的内存池：在对一些数据结构本身的内存进行分配时，需要从额外的内存池中申请，当该区域的内存不够时，会从缓冲池中进行申请。

### Checkpoint技术

对于数据库中页的修改操作，首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。为了避免发生数据丢失的问题，当事务提交时，先写重做日志，再修改页。当发生宕机而导致数据丢失时，通过重做日志来完成数据的恢复。

- 缩短数据库的恢复时间。
- 缓冲池不够用时，将脏页刷新到磁盘。
- 重做日志不可用时，刷新脏页。

### InnoDB逻辑存储结构

表都是根据主键顺序组织存放的，内存读取单位为页。

- 表空间：所有的数据都存放在表空间中。
- 段：表空间是由各个段组成的，如数据段、索引段、回滚段等。
- 区：区是由连续页组成的空间，任何情况下每个区的大小为1MB。
- 页：页是InnoDB磁盘管理的最小单位，默认每个页的大小为16KB。
- 行：InnoDB存储引擎是面向列的，也就是说数据是按行进行存放的。

### InnoDB数据页结构

- File Header：记录页的一些头信息。如页的偏移、上下页等。
- Page Header：记录页的状态信息。如页中记录的数量、页的索引树位置等。
- Infimum和Supremum Record：虚拟的行记录，用来限定记录的边界。
- User Record和Free Space：存储行记录的内容。
- Page Directory：存放了记录的相对位置。
- File Trailer：检测页是否已经完整地写入磁盘。

### 索引与算法

- B+树索引：平衡查找树。
  - 聚簇索引：按照每张表的主键构造一棵B+树，同时叶子节点存放的即为整张表的行记录数据。
  - 非聚簇索引：叶子节点不包含行记录数据，除了指定键值外，还包含一个主键。
    - 回表查询：从非聚簇索引中不可以得到查询的键值，而需要查询聚簇索引中的记录。
    - 覆盖索引：从非聚簇索引中可以得到查询的键值，而不需要查询聚簇索引中的记录。
    - 延迟关联：在分页里根据覆盖索引获得需要的键值，减少回表的次数。
- 哈希索引：根据表的使用情况自动为表生成哈希索引，不能人为生成。
- 全文索引：倒排索引。

### 锁的类型

- 共享锁（S Lock）：允许事务读一行数据。
- 排他锁（X Lock）：允许事务删除或更新一行数据。

如果需要对页上的记录上X锁，那么会对数据库、表、页上意向锁IX，最后对记录上X锁。

- 意向共享锁（IS Lock）：事务想要获得一张表中某几行的共享锁。
- 意向排他锁（IX Lock）：事务想要获得一张表中某几行的排他锁。

### 一致性非锁定读

通过MVCC来读取当前执行时间数据库中的数据。

- 在读取已提交事务隔离级别下，读取被锁定行的最新一份快照数据。
- 在可重复读事务隔离级别下，读取事务开始时的快照数据。

### 一致性锁定读

显式地对数据库读取操作进行加锁以保证数据逻辑的一致性。

- 共享锁：上S锁，其他事务可以向被锁定的行加S锁，如果加X锁会被阻塞，SELECT *** LOCK IN SHARE MODE。
- 排他锁：上X锁，其他事务不能对已锁定的行加上任何锁，SELECT *** FROM UPDATRE。

### 锁的算法

- Record Lock：单个行记录上的锁。
- Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。
- Next-Key Lock：Record Lock和Gap Lock，锁定一个范围，包含记录本身。

### 死锁

死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。

可通过超时、等待图（是否存在回路）解决。

### 锁升级

将锁的粒度变大，如行锁升级为页锁、表锁。锁是一种稀有资源，为了避免锁的开销会频繁出现锁升级现象。

### 锁表

Mysql在5.6版本之前，直接修改表结构的过程中会锁表，具体的操作步骤如下：

- 首先创建新的临时表，表结构通过命令ALTAR TABLE新定义的结构。
- 然后把原表中数据导入到临时表。
- 删除原表。
- 最后把临时表重命名为原来的表名。

Mysql 5.6虽然引入了Online DDL，但在一些场景下还是会锁表，比如

- 某个慢SQL或者比较大的结果集的SQL在运行，执行ALTER TABLE时将会导致锁表发生。
- 存在一个事务在操作表的时候，执行ALTER TABLE也会导致修改等待。

### 事务特性

- 原子性（Atomicity）：逻辑上是不可分割的操作单元，事务的所有操作要么全部提交成功，要么全部失败回滚（用回滚日志实现）。
- 一致性（Consistency）：事务的执行必须使数据库保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。
- 隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其它事务是不可见的（并发执行的事务之间不能相互影响）。
- 持久性（Durability）：一旦事务提交成功，对数据的修改是永久性的。

- redo log：保证原子性、持久性，重做日志，为了避免发生数据丢失的问题。
- undo log：保证一致性，回滚日志，保存了事务发生之前的数据版本。
- 锁：保证隔离性。

### 隔离级别

- Read Uncommitted（读取未提交）：脏读，在不同的事务下，当前事务可以读到其他事务未提交的数据。
- Read Committed（读取已提交）：不可重复读，在不同的事务下，当前事务可以读到其他事务已提交的数据，违反事务一致性的要求。
- Repeatable Read（可重读）：幻读，在同一事务下，连续执行两次SQL语句导致不同的结果，第二结果返回之前不存在的行。采用Next-Key Lock机制来避免幻读。
- Serializable（可串行化）：超时、锁竞争。

## 备份与恢复

- 热备
- 冷备
- 温备

### 读写分离

因为数据库的“写”（写10000条数据到mysql可能要3分钟）操作是比较耗时的。但是数据库的“读”（从mysql读10000条数据可能只要5秒钟）。所以读写分离，解决的是，数据库的写入，影响了查询的效率。

mysq支持的复制类型

- 基于语句的复制。在服务器上执行sql语句，在从服务器上执行同样的语句，mysql默认采用基于语句的复制，执行效率高。
- 基于行的复制。把改变的内容复制过去，而不是把命令在从服务器上执行一遍。
- 混合类型的复制。默认采用基于语句的复制，一旦发现基于语句无法精确复制时，就会采用基于行的复制。

复制的工作过程

- 在每个事务更新数据完成之前，master在二进制日志记录这些改变。写入二进制日志完成后，master通知存储引擎提交事务。
- Slave将master的binary log复制到其中继日志。首先slave开始一个工作线程（I/O），I/O线程在master上打开一个普通的连接，然后开始binlog dump process。binlog dump process从master的二进制日志中读取事件，如果已经跟上master，它会睡眠并等待master产生新的事件，I/O线程将这些事件写入中继日志。
- Sql slave thread（sql从线程）处理该过程的最后一步，sql线程从中继日志读取事件，并重放其中的事件而更新slave数据，使其与master中的数据一致，只要该线程与I/O线程保持一致，中继日志通常会位于os缓存中，所以中继日志的开销很小。

### 主从延迟

- 分库，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计。
- 打开MySQL支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了2000/s，并行复制还是没意义。
- 重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。
- 如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询设置直连主库。

### 复制

- 异步复制
- 半同步复制：也叫semi-sync复制，指的就是主库写入binlog日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的relay log之后，接着会返回一个ack给主库，主库接收到至少一个从库的ack之后才会认为写操作完成了。超时会退化为异步。
- 全同步复制：Group Replication。

## 数据库连接池

数据库连接的建立是一种耗时长、性能低、代价高的操作，频繁地进行数据库连接的建立和关闭会极大影响系统的性能，若多线程并发量很大，这样耗时的数据库连接就可能让系统变得卡顿。此外，数据库同时支持的连接总数也是有限的，达到上限后，后续线程发起的数据库连接就会失败。因此，数据库连接池是一种关键的、有限的、昂贵的资源，对于复杂的应用，如果频繁地建立、关闭连接，那么就会极大地影响系统的性能、伸缩性和健壮性。重用数据库连接最主要的原因是减少应用程序与数据库之间的创建和销毁TCP连接的开销，数据库连接池的概念应运而生。

### 未用连接池的问题

- 创建连接和关闭连接的过程比较耗时，并发时系统卡顿。
- 数据库同时支持的连接总数有限，总数耗光后面的请求会失败，造成浪费数据库资源、内存溢出、宕机等。
- 为了执行一条SQL，产生了不必要的网络IO。
- 应用频繁创建连接和关闭连接，导致jvm临时对象多，gc频繁。
- 频繁关闭后，出现大量TIME_WAIT的TCP状态。

### 连接池的优点

- 资源重用更佳
- 系统调优更简便
- 系统响应更快
- 连接管理更灵活

### 连接池原理

在系统初始化的时候，在内存中开辟一片空间，将一定数量的数据库连接作为对象存储在对象池里，并对外提供数据库连接的获取和归还方法。用户访问数据库时，并不是建立一个新的连接，而是从数据库连接池中取出一个已有的空闲连接对象；使用完毕归还后的连接也不会马上被关闭，而是由数据库连接池统一管理回收，为下一次借用做好准备。如果由于高并发请求导致数据库连接池中的连接被借用完毕，其他线程就会等待，直到有连接被归还。整个过程中，连接并不会被关闭，而是源源不断地循环使用，有借有还。数据库连接池还可以通过设置其参数来控制连接池中的初始连接数、连接的上下限数，以及每个连接的最大使用次数、最大空闲时间等，也可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。

### 连接池的构成

- 数据库连接池以连接池的管理为核心，主要支持连接池的建立和释放两大核心功能，还包括以下附加功能。
- 并发：锁性能优化乃至无锁。
- 连接数控制：不同的系统对连接数有不同的需求。
- 监控：一些自身管理机制来监视连接的数量及使用情况等。
- 外部配置：各种主流数据库连接池官方文档最核心的部分。
- 资源重用：数据库连接池的核心思想。
- 检测及容灾：面对一些网络、时间等问题的自愈。
- 多库多服务：如不同的数据库、不同的用户名和密码、分库分表等情况。
- 事务处理：对数据库的操作符合ALL-ALL-NOTHING原则。
- 定时任务：如空闲检查、最小连接数控制。
- 缓存：如PSCache等避免对SQL重复解析。
- 异常处理：对JDBC访问的异常统一处理。
- 组件维护：如连接状态、JDBC封装的维护。

## 分库分表

### 分区表

分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对SQL层来说是一个完全封装底层的黑盒子。MySQL实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引。

### 分区类型

- RANGE：从0到10000一个表，10001到20000一个表；
- HASH：一个商场系统，一般都是将用户，订单作为主表，然后将和它们相关的作为附表，这样不会造成跨库事务之类的问题。 取用户id，然后hash取模，分配到不同的数据库上。
- 地理区域：比如按照华东，华南，华北这样来区分业务，七牛云应该就是如此。
- 时间：按照时间切分，就是将6个月前，甚至一年前的数据切出去放到另外的一张表，因为随着时间流逝，这些表的数据被查询的概率变小，所以没必要和热数据放在一起，这个也是冷热数据分离。
